import math


# A third degree polynomial
struct PolyEngine {
  c : float  = 0
  b : float = 0
  a : float = 0
}

method f(p : PolyEngine, x : float) : float {
  return x * (p.c + x * (p.b + x * p.a))
}

method df(p : PolyEngine, x : float) : float {
  return p.c + x * (2 * p.b + 3 * p.a * x)
}

function poly(n1:float, n2:float) : PolyEngine {
  let cc = 3 * n1
  let bb = 3 * (n2 - n1) - cc
  let aa = 1 - cc - bb
  return new PolyEngine({
    a = aa
    b = bb
    c = cc
  })
}

export struct CubicBezierEngine {
  x : PolyEngine = null
  y : PolyEngine = null
}
export method at(cb : CubicBezierEngine, n : float) : float {
  if n < 0 {
    return 0
  } else if n > 1 {
    return 1
  }

  mut v = n

  for i = 0 upto 5 {
    let z = cb.x.f(v) - n

    # Finish if we're close enough
    if (z.abs() < 0.001) {
      break
    }

    v = v - z / cb.x.df(v)
  }
  return cb.y.f(v)
}

export function cubicBezier(x1 : float, y1 : float, x2 : float, y2 : float) : CubicBezierEngine {
  let result = new CubicBezierEngine()

  # Bezier polynomials
  result.x = poly(x1, x2)
  result.y = poly(y1, y2)

  return result
}

export function ease(d : int) : func<int, float> {
  let cb = cubicBezier(0.25, 0.1, 0.25, 1.0)

  return lambda(t : int) : float {
    return cb.at(t / (d*1.0))
  }
}

export function linear(d : int) : func<int, float> {
  let cb = cubicBezier(0f, 0f, 1f, 1f)

  return lambda(t : int) : float {
    return cb.at(t / (d*1.0))
  }
}

export function easeIn(d : int) : func<int, float> {
  let cb = cubicBezier(0.42, 0f, 1f, 1f)

  return lambda(t : int) : float {
    return cb.at(t / (d*1.0))
  }
}

export function easeOut(d : int) : func<int, float> {
  let cb = cubicBezier(0f, 0f, 0.58, 1f)

  return lambda(t : int) : float {
    return cb.at(t / (d*1.0))
  }
}

export function easeInOut(d : int) : func<int, float> {
  let cb = cubicBezier(0.42, 0f, 0.58, 1f)

  return lambda(t : int) : float {
    return cb.at(t / (d*1.0))
  }
}
