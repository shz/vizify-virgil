import math


# A third degree polynomial
struct PolyEngine {
  c : float = 0f
  b : float = 0f
  a : float = 0f
}

method f(p : PolyEngine, x : float) : float {
  return x * (p.c + x * (p.b + x * p.a))
}

method df(p : PolyEngine, x : float) : float {
  return p.c + x * (2f * p.b + 3f * p.a * x)
}

function poly(n1:float, n2:float) : PolyEngine {
  let cc = 3f * n1
  let bb = 3f * (n2 - n1) - cc
  let aa = 1f - cc - bb
  return new PolyEngine {
    a = aa
    b = bb
    c = cc
  }
}

export struct CubicBezierEngine {
  x : PolyEngine = null
  y : PolyEngine = null
}
export method at(cb : CubicBezierEngine, n : float) : float {
  if n < 0 {
    return 0f
  } else if n > 1 {
    return 1f
  }

  mut v = n

  for i = 0 upto 5 {
    let z = cb.x.f(v) - n

    # Finish if we're close enough
    if (z.abs() < 0.001) {
      break
    }

    v = v - z / cb.x.df(v)
  }
  return cb.y.f(v)
}

export function cubicBezier(x1 : float, y1 : float, x2 : float, y2 : float) : CubicBezierEngine {
  let result = new CubicBezierEngine

  # Bezier polynomials
  result.x = poly(x1, x2)
  result.y = poly(y1, y2)

  return result
}

export function ease(d : int) : func<int, float> {
  if (d > 0) {
    let cb = cubicBezier(0.25, 0.1, 0.25, 1.0)
    return lambda(t : int) : float {
      return cb.at(t.asFloat() / d.asFloat())
    }
  }else{
    return lambda(t : int) : float {
      return 1f
    }
  }
}

export function easeCustomShape(d : int, cb : CubicBezierEngine) : func<int, float> {
  return lambda(t : int) : float {
    return cb.at(t.asFloat() / d.asFloat())
  }
}

export function linear(d : int) : func<int, float> {
  let cb = cubicBezier(0f, 0f, 1f, 1f)

  return lambda(t : int) : float {
    return cb.at(t.asFloat() / d.asFloat())
  }
}

export function easeIn(d : int) : func<int, float> {
  let cb = cubicBezier(0.42, 0f, 1f, 1f)

  return lambda(t : int) : float {
    return cb.at(t.asFloat() / d.asFloat())
  }
}

export function easeOut(d : int) : func<int, float> {
  let cb = cubicBezier(0f, 0f, 0.58, 1f)

  return lambda(t : int) : float {
    return cb.at(t.asFloat() / d.asFloat())
  }
}

export function easeInOut(d : int) : func<int, float> {
  let cb = cubicBezier(0.42, 0f, 0.58, 1f)

  return lambda(t : int) : float {
    return cb.at(t.asFloat() / d.asFloat())
  }
}
