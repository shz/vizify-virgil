import math

struct PolyEngine {
  c : float  = 0
  b : float = 0
  a : float = 0
}
method f(p : PolyEngine, x : float) : float {
  return x * (p.c + x * (p.b + x * p.a))
}
method df(p : PolyEngine, x : float) : float {
  return p.c + x * (2 * p.b + 3 * p.a * x)
}

export struct CubicBezierEngine {
  x : PolyEngine = null
  y : PolyEngine = null
}
export method f(cb : CubicBezierEngine, n : float) : float {
  mut v = n

  for i = 0 upto 5 {
    let z = cb.x.f(v) - n

    # // Finish if we're close enough
    if (z.abs() < 0.001) {
      break
    }

    v = v - z / cb.x.df(v)
  }
  return cb.y.f(v)
}
export method at(engine:CubicBezierEngine, t:float) : float {
  return engine.f(t)
}

function poly(n1:float, n2:float) : PolyEngine {
  let cc = 3 * n1
  let bb = 3 * (n2 - n1) - cc
  let aa = 1 - cc - bb
  return new PolyEngine({
    a = aa
    b = bb
    c = cc
  })
}


export function generateCubicBezierEngine(x1:float, y1:float, x2:float, y2:float) : CubicBezierEngine {
  let result = new CubicBezierEngine()

  # Bezier polynomials
  result.x = poly(x1, x2)
  result.y = poly(y1, y2)

  return result
}



export struct EasingLibrary {
  ease = generateCubicBezierEngine(0.25, 0.1, 0.25, 1f)
  linear = generateCubicBezierEngine(0f, 0f, 1f, 1f)
  easeIn = generateCubicBezierEngine(0.42, 0f, 1f, 1f)
  easeOut = generateCubicBezierEngine(0f, 0f, 0.58, 1f)
  easeInOut = generateCubicBezierEngine(0.42, 0f, 0.58, 1f)
  endAtStop = generateCubicBezierEngine(0.38,0.65,0.52,1f)
}
