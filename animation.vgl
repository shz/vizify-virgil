import env
import clock
import canvas

import animTreeDiag

export extern {
  function querySt(key : str, valDefault : str) : str
  function consoleLog(val : str)
}

export method fade(rc : RenderContext<'T>, inDur : int, outDur : int) : RenderContext<'T> {
  let root = rc.fork()
  root.config.operations.push(lambda(ctx : Canvas, clock : Clock) {
    if clock.fromStart < inDur {
      ctx.setGlobalAlpha(1f * clock.fromStart / inDur)
    } else if clock.fromEnd < outDur {
      ctx.setGlobalAlpha(1f * clock.fromEnd / outDur)
    }
  })
  animTreeRecordPush("fade " + (inDur*1f).format(0) + "," + (outDur*1f).format(0), root.config)
  return root
}

export method delay(rc : RenderContext<'T>, amount : int) : RenderContext<'T> {
  let root = rc.fork()
  root.config.start = amount
  animTreeRecordPush("delay", root.config)
  return root
}

export method runFor(rc : RenderContext<'T>, amount : int) : RenderContext<'T> {
  let root = rc.fork()
  root.config.duration = amount
  root.config.end = -1
  animTreeRecordPush("runFor", root.config)
  return root
}

export method runUntil(rc : RenderContext<'T>, amount : int) : RenderContext<'T> {
  let root = rc.fork()
  root.config.start = 0
  root.config.end = amount
  animTreeRecordPush("runUntil", root.config)
  return root
}

export method draw(rc : RenderContext<'T>, f : func<RenderContext<'T>, void>) {

  # Sanity check on duration
  if ( (rc.config.end > 0) && (rc.config.duration > -1) ) {
    # TODO: throw new Error('This chain has both an end time and a duration, which is invalid');
  }

  # Do some timing calculation
  mut fromStart = rc.clock.fromStart - rc.config.start
  mut fromEnd = (rc.config.duration < 0) ? (rc.clock.fromEnd - rc.config.end) : (rc.config.start + rc.config.duration - rc.clock.fromStart)

  animTreeRecordDrawStart(rc)

  # Skip if we don't need to be drawn right now
  if ((fromStart < 0) || (fromEnd < 0)) {
    if (animTreeInRecordingMode()) {
      # ARTIFICIAL CLOCK MOVEMENT TO FORCE ENTRY INTO THIS SUBSCENE FOR RECORDING BENEFIT
      if (fromStart < 0) {
        if (rc.config.duration > 0) {
          ### vvvvv IT IS NOT CLEAR THAT THIS IS NEEDED!!!!
          # Adjust the clock and config to simulate future time
          #rc.clock.fromEnd = rc.config.duration
          #rc.clock.fromStart = 0
          #rc.clock.percent = 0
          #rc.config.duration = -1
          #rc.config.end = 0
          ### ^^^^^ IT IS NOT CLEAR THAT THIS IS NEEDED!!!!
        }
        fromEnd = fromEnd + fromStart
        fromStart = 0
      } 
    }else{
      animTreeRecordDrawEnd(rc)
      return void
    }   
  }

  # Create a new, time-adjust render context for the actual call
  let root = rc.fork()
  root.clock.fromStart = fromStart
  root.clock.fromEnd = fromEnd
  root.clock.percent = 1f * fromStart / (fromStart + fromEnd)
  root.config.duration = -1
  root.config.end = 0
  root.config.start = 0

  # Apply the operation stack
  root.c.save()
  for i = 0 upto root.config.operations.length {
    root.config.operations[i](root.c, root.clock)
  }

  root.config.operations = new list<func<Canvas, Clock, void>>()
  f(root)

  # Unwind the operation stack
  rc.c.restore()

  animTreeRecordDrawEnd(rc)
}

export method drawNamedGroup(rc : RenderContext<'T>, name: str, f : func<RenderContext<'T>, void>) {
  animTreeDeclareDrawGroup(name)
  rc.draw(f)
}
  
